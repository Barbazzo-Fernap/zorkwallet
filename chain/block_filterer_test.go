package chain_test

import (
	"reflect"
	"testing"
	"time"

	"github.com/ltcsuite/ltcd/chaincfg"
	"github.com/ltcsuite/ltcd/chaincfg/chainhash"
	"github.com/ltcsuite/ltcd/ltcutil"
	"github.com/ltcsuite/ltcd/wire"
	"github.com/ltcsuite/ltcwallet/chain"
)

var Block234569 = wire.MsgBlock{
	Header: wire.BlockHeader{
		Version: 1,
		PrevBlock: chainhash.Hash([32]byte{ // Make go vet happy.
			0xed, 0x7f, 0x7f, 0x71, 0xec, 0x01, 0x36, 0xea,
			0x2e, 0x4d, 0x7f, 0x34, 0x87, 0xe9, 0x04, 0x19,
			0x0f, 0x5f, 0x50, 0xfb, 0xcb, 0x40, 0xdd, 0x8c,
			0x04, 0xa5, 0x2e, 0x7c, 0x06, 0x4d, 0x0a, 0x84,
		}), // 840a4d067c2ea5048cdd40cbfb505f0f1904e987347f4d2eea3601ec717f7fed
		MerkleRoot: chainhash.Hash([32]byte{ // Make go vet happy.
			0x88, 0xe2, 0xc8, 0xf5, 0xf5, 0x7d, 0xc5, 0x95,
			0xbe, 0x29, 0x86, 0x4a, 0x97, 0x95, 0xfa, 0x55,
			0x9e, 0x39, 0x45, 0xca, 0x0c, 0xf9, 0xae, 0xa0,
			0x5d, 0x14, 0x64, 0x8f, 0xda, 0xbd, 0x92, 0x32,
		}), // 3292bdda8f64145da0aef90cca45399e55fa95974a8629be95c57df5f5c8e288
		Timestamp: time.Unix(1351288996, 0), // 2012-10-26 22:03:16 ++0000 UTC
		Bits:      0x1c0b1c73,               // 470490227
		Nonce:     0x67d40300,               // 1741947648
	},
	Transactions: []*wire.MsgTx{
		{
			Version: 1,
			TxIn: []*wire.TxIn{
				{
					PreviousOutPoint: wire.OutPoint{
						Hash:  chainhash.Hash{},
						Index: 0xffffffff,
					},
					SignatureScript: []byte{
						0x04, 0xa4, 0x08, 0x8b, 0x50, 0x02, 0xe5, 0x0c,
						0x06, 0x2f, 0x50, 0x32, 0x53, 0x48, 0x2f,
					},
					Sequence: 0xffffffff,
				},
			},
			TxOut: []*wire.TxOut{
				{
					Value: 0x12a05f200, // 5000000000
					PkScript: []byte{
						0x21, // OP_PUSHBYTES_33
						0x03, 0x33, 0xc2, 0x77, 0xa9, 0x35, 0xb6, 0x75,
						0xd5, 0xb1, 0xcb, 0x21, 0x2d, 0x3a, 0x2e, 0x98,
						0xd2, 0x2d, 0xc2, 0xbd, 0x58, 0x9c, 0x86, 0xeb,
						0x2e, 0x72, 0x8d, 0x8b, 0xee, 0xba, 0x6f, 0x86,
						0xe8, // 65-byte signature
						0xac, // OP_CHECKSIG
					},
				},
			},
			LockTime: 0,
		},
		{
			Version: 1,
			TxIn: []*wire.TxIn{
				{
					PreviousOutPoint: wire.OutPoint{
						Hash: chainhash.Hash([32]byte{ // Make go vet happy.
							0x2a, 0x59, 0x59, 0x3a, 0xcf, 0x08, 0xcb,
							0x7a, 0x99, 0x44, 0xe5, 0x8e, 0xb9, 0x6b,
							0xb4, 0xf4, 0x94, 0x5d, 0xc7, 0xe2, 0x14,
							0x4f, 0x5c, 0xd2, 0x8c, 0x88, 0x5e, 0x21,
							0x2e, 0x15, 0xd5, 0x75,
						}), // 75d5152e215e888cd25c4f14e2c75d94f4b46bb98ee544997acb08cf3a59592a
						Index: 0,
					},
					SignatureScript: []byte{
						0x47, // OP_PUSHBYTES_71
						0x30, 0x44, 0x02, 0x20, 0x2c, 0x7f, 0x99, 0xf6,
						0x16, 0xc9, 0xbc, 0x75, 0x21, 0x11, 0xbf, 0x98,
						0x3d, 0x1a, 0xb9, 0xb3, 0x0d, 0xb2, 0x31, 0x22,
						0x63, 0x16, 0x95, 0xe6, 0x23, 0x4e, 0x34, 0xc6,
						0x9b, 0x3c, 0xf2, 0x58, 0x02, 0x20, 0x47, 0xc3,
						0x05, 0xf7, 0xc1, 0x4f, 0x21, 0xdb, 0x9a, 0xe1,
						0x6e, 0x06, 0x35, 0x06, 0xe1, 0xba, 0x15, 0xde,
						0xca, 0xea, 0x79, 0x5c, 0x68, 0x0b, 0x50, 0x51,
						0xab, 0x66, 0x43, 0x4b, 0x15, 0x25,
						0x01,
					},
					Sequence: 0xffffffff,
				},
			},
			TxOut: []*wire.TxOut{
				{
					Value: 0x105186504, // 4380452100
					PkScript: []byte{
						0x76, // OP_DUP
						0xa9, // OP_HASH160
						0x14, // OP_DATA_20
						0xb7, 0x67, 0x89, 0x50, 0xa2, 0x4b, 0xbe, 0x27,
						0x67, 0xe2, 0xad, 0x8c, 0x42, 0x23, 0x06, 0x33,
						0xb1, 0x0d, 0x92, 0xeb,
						0x88, // OP_EQUALVERIFY
						0xac, // OP_CHECKSIG
					},
				},
				{
					Value: 0x261eb9fc, // 639547900
					PkScript: []byte{
						0x76, // OP_DUP
						0xa9, // OP_HASH160
						0x14, // OP_DATA_20
						0x40, 0x8f, 0x09, 0x2d, 0x02, 0x00, 0x95, 0x29,
						0x5a, 0x0d, 0x7c, 0x4b, 0xff, 0xf9, 0x7f, 0x80,
						0xf2, 0x04, 0x95, 0xfc,
						0x88, // OP_EQUALVERIFY
						0xac, // OP_CHECKSIG
					},
				},
			},
			LockTime: 0,
		},
		{
			Version: 1,
			TxIn: []*wire.TxIn{
				{
					PreviousOutPoint: wire.OutPoint{
						Hash: chainhash.Hash([32]byte{ // Make go vet happy.
							0x1d, 0xe3, 0x60, 0x8e, 0x03, 0xb4, 0x59, 0xc3,
							0x2c, 0xed, 0xf4, 0xc1, 0x46, 0x9c, 0x45, 0xcd,
							0x65, 0xb0, 0x53, 0x92, 0x3c, 0x06, 0xa7, 0x2a,
							0xef, 0xe3, 0x7a, 0x12, 0x98, 0x2b, 0x74, 0x93,
						}), // 93742b98127ae3ef2aa7063c9253b065cd459c46c1f4ed2cc359b4038e60e31d
						Index: 1,
					},
					SignatureScript: []byte{
						0x47, // OP_PUSHBYTES_71
						0x30, 0x44, 0x02, 0x20, 0x1c, 0x40, 0xf4, 0x42, 0x63,
						0x26, 0xbb, 0x6f, 0xeb, 0x23, 0xef, 0xaf, 0x8f, 0xce,
						0xca, 0xb0, 0x75, 0x4e, 0x65, 0x4c, 0x95, 0x77, 0xc4,
						0xaf, 0x81, 0x8f, 0x9c, 0x10, 0x56, 0x99, 0xba, 0xf8,
						0x02, 0x20, 0x3c, 0x56, 0x6b, 0xfd, 0xbb, 0x57, 0x7a,
						0xf5, 0x52, 0x1c, 0x98, 0x88, 0x21, 0x05, 0xbb, 0xac,
						0x25, 0xf7, 0x9b, 0x23, 0x4a, 0xa0, 0xc3, 0x03, 0xd8,
						0x23, 0xd3, 0x22, 0x3d, 0x0e, 0x79, 0x02,
						0x01,
					},
					Sequence: 0xffffffff,
				},
			},
			TxOut: []*wire.TxOut{
				{
					Value: 0x17f10e48, // 401673800
					PkScript: []byte{
						0x76, // OP_DUP
						0xa9, // OP_HASH160
						0x14, // OP_DATA_20
						0x83, 0x2b, 0x30, 0x60, 0x5a, 0x0f, 0x23, 0x48,
						0xa1, 0xfc, 0xc7, 0x1c, 0x1f, 0xff, 0x37, 0x8b,
						0xab, 0x82, 0x75, 0x22,
						0x88, // OP_EQUALVERIFY
						0xac, // OP_CHECKSIG
					},
				},
				{
					Value: 0x11d260c0, // 4598326200
					PkScript: []byte{
						0x76, // OP_DUP
						0xa9, // OP_HASH160
						0x14, // OP_DATA_20
						0x65, 0x57, 0x5b, 0x1c, 0x01, 0xfd, 0xf2, 0xca,
						0x6e, 0x3a, 0xdd, 0x5a, 0xf4, 0xb1, 0x4a, 0x9c,
						0xa3, 0x7a, 0x95, 0x5b,
						0x88, // OP_EQUALVERIFY
						0xac, // OP_CHECKSIG
					},
				},
			},
			LockTime: 0,
		},
		{
			Version: 1,
			TxIn: []*wire.TxIn{
				{
					PreviousOutPoint: wire.OutPoint{
						Hash: chainhash.Hash([32]byte{ // Make go vet happy.
							0x99, 0xda, 0xa8, 0x48, 0x6f, 0xf8, 0x1f, 0x90,
							0x93, 0x32, 0x08, 0x55, 0xf6, 0xd6, 0x36, 0xb4,
							0xd2, 0x5e, 0x97, 0x9c, 0x7c, 0x47, 0xe2, 0xa4,
							0xac, 0xf5, 0x6e, 0xf2, 0xde, 0xab, 0xb0, 0x1c,
						}), // 1cb0abdef26ef5aca4e2477c9c975ed2b436d6f655083293901ff86f48a8da99
						Index: 0,
					},
					SignatureScript: []byte{
						0x48, // OP_PUSHBYTES_72
						0x30, 0x45, 0x02, 0x21, 0x00, 0xbf, 0xe7, 0x27,
						0x1b, 0x45, 0x38, 0xc9, 0x26, 0xe5, 0x4c, 0xcb,
						0x62, 0x0b, 0x06, 0x5a, 0x7b, 0x74, 0x56, 0x98,
						0xe3, 0xc5, 0xab, 0x2b, 0x9d, 0x36, 0x14, 0x76,
						0x79, 0x0a, 0x7f, 0x54, 0xbd, 0x02, 0x20, 0x78,
						0x63, 0xec, 0xf4, 0x0d, 0x1d, 0xea, 0xab, 0x38,
						0x33, 0x3e, 0xaf, 0x6c, 0xdb, 0xaf, 0x47, 0x8a,
						0x2d, 0x79, 0x7f, 0xf4, 0x73, 0xee, 0x1f, 0x81,
						0xbe, 0x6b, 0x7a, 0x0a, 0x9d, 0xae, 0x0c, 0x01,
						0x21, // OP_PUSHBYTES_33
						0x03, 0xa8, 0x85, 0x4d, 0x1e, 0x3d, 0xda, 0x95,
						0x0f, 0x1c, 0xe8, 0xd6, 0x42, 0x59, 0x0d, 0x3c,
						0xd2, 0xc7, 0x29, 0x20, 0xb2, 0x02, 0x4e, 0x00,
						0xb2, 0x68, 0x5d, 0x51, 0xce, 0x84, 0x31, 0x69,
						0xb6,
					},
					Sequence: 0xffffffff,
				},
			},
			TxOut: []*wire.TxOut{
				{
					Value: 0x3cf0f0c4, // 10.22423236
					PkScript: []byte{
						0x76, // OP_DUP
						0xa9, // OP_HASH160
						0x14, // OP_DATA_20
						0xef, 0x5a, 0xe5, 0x0a, 0x97, 0xa9, 0x28, 0x55,
						0xb3, 0x5c, 0xce, 0x01, 0x07, 0x79, 0x6e, 0x13,
						0xf3, 0x64, 0xbb, 0x4e,
						0x88, // OP_EQUALVERIFY
						0xac, // OP_CHECKSIG
					},
				},
				{
					Value: 0x4bb1f9f8, // 12.69955064
					PkScript: []byte{
						0x76, // OP_DUP
						0xa9, // OP_HASH160
						0x14, // OP_DATA_20
						0x02, 0x14, 0x6f, 0x97, 0x98, 0xa9, 0x8d, 0x25,
						0xed, 0x75, 0x6a, 0x31, 0xa6, 0x66, 0xa1, 0x93,
						0x50, 0xe8, 0x27, 0x71,
						0x88, // OP_EQUALVERIFY
						0xac, // OP_CHECKSIG
					},
				},
			},
			LockTime: 0,
		},
	},
}

// TestBlockFiltererOneInOneOut tests the correctness of the BlockFilterer in
// finding outpoints that spend from a "watched outpoint", even if they do not
// send to an address controlled by the wallet.
func TestBlockFiltererOneInOneOut(t *testing.T) {
	// Watch for spend from prev in in first and last tx, both of which are
	// single input/single output.
	firstTx := Block234569.Transactions[1]
	lastTx := Block234569.Transactions[3]

	// Add each of their single previous outpoints to the set of watched
	// outpoints to filter for.
	watchedOutPoints := make(map[wire.OutPoint]ltcutil.Address)
	watchedOutPoints[firstTx.TxIn[0].PreviousOutPoint] = &ltcutil.AddressWitnessPubKeyHash{}
	watchedOutPoints[lastTx.TxIn[0].PreviousOutPoint] = &ltcutil.AddressWitnessPubKeyHash{}

	// Construct a filter request, watching only for the outpoints above,
	// and construct a block filterer.
	req := &chain.FilterBlocksRequest{
		WatchedOutPoints: watchedOutPoints,
	}
	blockFilterer := chain.NewBlockFilterer(&chaincfg.SimNetParams, req)

	// Filter block 100000, which should find matches for the watched
	// outpoints.
	match := blockFilterer.FilterBlock(&Block234569)
	if !match {
		t.Fatalf("failed to find matches when filtering for " +
			"1-in-1-out txns")
	}

	// We should find exactly two relevant transactions added to the block
	// filterer, then we check that both the first and last txns are found
	// in that list.
	assertNumRelevantTxns(t, blockFilterer, 2)
	assertRelevantTxnsContains(t, blockFilterer, firstTx)
	assertRelevantTxnsContains(t, blockFilterer, lastTx)
}

// assertNumRelevantTxns checks that the set of relevant txns found in a block
// filterer is of a specific size.
func assertNumRelevantTxns(t *testing.T, bf *chain.BlockFilterer, size int) {
	count := len(bf.RelevantTxns)
	if count != size {
		t.Fatalf("unexpected number of relevant txns: "+
			"want %v, got %v", size, count)
	}
}

// assertRelevantTxnsContains checks that the wantTx is found in the block
// filterers set of relevant txns.
func assertRelevantTxnsContains(t *testing.T, bf *chain.BlockFilterer, wantTx *wire.MsgTx) {
	for _, relevantTx := range bf.RelevantTxns {
		if reflect.DeepEqual(relevantTx, wantTx) {
			return
		}
	}

	t.Fatalf("unable to find tx: %x in %d relevant txns", wantTx.TxHash(),
		len(bf.RelevantTxns))
}
